---
title: "R Notebook"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tuneR)
```

## Amplitude
  
+ Instantaneous amplitude  
+ Maximum amplitude  
+ Peak-to-peak  
+ Root-mean-square amplitude (rms, RMS)  
(ch. 2.2.3. p.12-13)  
  
crest amplitude - максимальна амплітуда  
  

## Frequency (ch.2.2.6, p.21)  
  
## Sampling and Quatization (ch 2.4.1, p.30)  
  
**sampling frequency, sampling rate** - частота дискретизації  
**Sampling** - дискретизація  
**Amplitude Envelope** - огинаюча амплітуди  

[Sampling Theory](https://www.vicmyers.com/wp-content/uploads/spectrum_analysis.pdf)

## Smoothing. Sliding Window Process (ch.5.2.3, p.130)  
  
  
Moving Average
  
## Fourie Transform  (ch.9, p.216)
  
+ **Fourier series (FS)** - Decomposition of a periodic signal into an infinite sum of harmonics  

+ **Fourier transform (FT)** - Transformation of an infinite signal from the time (or spatial) domain to the frequency domain  

+ **Discrete Fourier transform (DFT)** - Transformation of a discrete time-limited signal to a discrete frequency spectrum  

+ **Fast Fourier transform (FFT)** - Mathematical tool and algorithm to compute the DFT  
The FFT is not another kind of Fourier transformation but a tool in mathematics, or algorithm in computer
sciences, that can process the DFT very efficiently.  

+ **Short-time Fourier transform (STFT)** - Sliding FT along an infinite signal  

+ **Short-time discrete Fourier transform (STDFT)** - Sliding DFT along a time-limited signal  
  
### FFT  
  
(p.226)
However the total energy of the time and frequency signals are preserved as stated
by Parseval’s theorem which stipulates that the sum of the square of a function is
equal to the sum of the square of its transform.
  
## Amplitude Scales (ch.9.5, p.235)  
  

## Key concepts  
  
Sliding windows ()
Sampling  
skewness (p.171)  
kurtosis (p.171)  
Amplitude Modulation Analysis (ch.8, p.205)  

# Example Fourier Transform  
  
(from book sueur_j_sound_analysis_and_synthesis_with_r, p.219)  
  
![](img/FFT_explanation_base_signal.png)

The waveform shown in Fig. 9.3 obeys to the following equation:  
$s( t ) = 0.5 + 0.3cos( t )+2sin( 2t )+3sin( 3t)-4cos( 4t )+sin( 10t )$  
Imagine that this waveform is a sound sampled at a frequency $f_s = 44,100$ during 1 s with a fundamental frequency $f_0 = 440 Hz$. The waveform is therefore made of 44,100 samples with a period 44,100 ÷ 440 = 100.2273 samples that can be approximated to 100 samples. We can try to find the coefficients (An , Bn) with the formula above. We start by generating the 440 Hz sound with:  
```{r}
f <- 44100                         # sampling frequency
t <- seq(1/f, 1, length.out=f)     # time
T <- 1/440                         # 440 Hz period
w0 <- 2*pi/T                       # 440 Hz angular frequency
h0 <- 1*cos(w0*t)                  # 440 Hz fundamental frequency
h1 <- 2*cos(2*w0*t)                # 880 Hz harmonic
h2 <- 3*sin(3*w0*t)                # 1320 Hz harmonic
h3 <- -4*cos(4*w0*t)               # 1760 Hz harmonic
h10 <- 10*sin(10*w0*t)             # 4400 Hz harmonic
s <- 2.5 + h0 + h1 + h2 + h3 + h10 # final signal
```
NOT CORRECT!!! Signal reconstruction  
```{r}
plot(s[1:200], type = "l")
```
  
In R, the FFT is implemented in the function fft(). The use of this function is rather simple; we just need to provide the signal as an input:
```{r}
fft2 <- fft(s)
#spectrum(fft2)
```
To produce the discrete frequency spectrum, we have to compute the complex modulus of the FFT, directly obtained with the function Mod()
```{r}
fspec <- Mod(fft2)
```
The frequency spectrum can be visualized by calling plot() with type="h" to draw a vertical line corresponding to the amplitude of each angular frequency. The frequency resolution is here 1 Hz because the sound analyzed lasts 1 s.
```{r}
plot(fspec, type="h", col="blue", xlab="Frequency (Hz)", ylab="Amplitude (no unit)")
```
Figure 9.7 shows that the modulus of the Fourier transform is a symmetric, or mirrored, function around half the sampling frequency or Nyquist frequency $f_N$ , here $f_N = f _s ÷ 2 = 22,050 Hz$. This symmetry is one of the main properties of the Fourier transform due to the symmetric properties of the cosine and sine functions.  
We zoom in on the left half of the spectrum, and we multiply the amplitude values by 2 to keep the total amount of energy:
```{r}
fspec.left <- 2*fspec[1:(f/2)]
plot(fspec.left, type="h", col="blue", xlab="Frequency (Hz)", ylab="Amplitude (no unit)", xlim = c(0, 5000))
```
Identify peaks (manual)
```{r}
#peaks <- identify(fspec.left)
peaks <- c(0, 440, 880, 1320, 1760, 4400)
```

## How to use spectrum() function 

**[How to tune spectrum parameters]**(https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/spectrum)  
**[How to tune spec.pgram parameters]**(https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/spec.pgram)  
  
Here we will repeat previous example using **spectrum()** function. Example that will helps us is here [Spectral analysis in R](https://ms.mcmaster.ca/~bolker/eeid/2010/Ecology/Spectral.pdf)  
  
The spectrum function defaults to a logarithmic scale for the spectrum, but we can change this by setting the log parameter to ”no”. The default frequency axis is in cycles per sampling interval. It is more intuitive to convert the frequency axis to cycles per unit time, we can do this by extracting the frequency values that R returns and dividing by the length of the sampling interval. We should also multiply the spectral density by 2 so that the area under the periodogram actually equals the variance of the time series.  

> del<-0.1 # sampling interval
  x.spec <- spectrum(x,log="no",span=10,plot=FALSE)
  spx <- x.spec$freq/del
  spy <- 2*x.spec$spec
  plot(spy~spx,xlab="frequency",ylab="spectral density",type="l")

Frequencies to observe: c(0, 440, 880, 1320, 1760, 4400)

Detrending: we want to see constant value at zero frequency 
```{r}
del <- 1/f # 1/44100
x.spec <- spectrum(s, log = "no", span = 10, plot = FALSE, detrend = F, demean = F)
spx <- x.spec$freq / del  # or multipy by f
spy <- 2*x.spec$spec
plot(spy ~ spx, xlab="frequency", ylab="spectral density", type="l", xlim = c(0, 2000), ylim = c(0, 20000))
```
See x.spec parameters:
```{r}
str(x.spec)
```
We want to replace constant value and all trends:
```{r}
del <- 1/f # 1/44100
x.spec <- spectrum(s, log = "no", span = 10, plot = FALSE, detrend = T, demean = T)
spx <- x.spec$freq / del  # or multipy by f
spy <- 2*x.spec$spec
plot(spy ~ spx, xlab="frequency", ylab="spectral density", type="l", xlim = c(0, 2000), ylim = c(0, 20000))
```
Compare the total energy of time and frequence domain:
Time energy:
```{r}
sum(s^2)
```
Frequency energy by manual:
```{r}
1/length(fspec) * sum(fspec^2)
```
Frequency energy by spectrum() 
```{r}
ex.spec <- spectrum(s, log = "no", span = NULL, plot = FALSE, detrend = F, demean = F)
1/length(ex.spec$spec) * sum(ex.spec$spec^2)
```
Frequencies to observe: c(0, 440, 880, 1320, 1760, 4400)  
Pure spectrum() without log scale and  detrending
```{r}
sp0 <- spectrum(s, log = "no", span = NULL, plot = T)  #xlim = c(0, 0.1))
```

Pure spectrum() without log scale and with detrending
```{r}
sp1 <- spectrum(s, log = "no", span = 10, plot = T, xlim = c(0, 0.1))
```
What magnitude is on zero freaquency:
```{r}
sp1$spec[1]
```
Pure spectrum() without detrending
```{r}
sp2 <- spectrum(s, log = "no", span = 10, plot = T, detrend = F, demean = F, xlim = c(0, 0.1))
```
What magnitude is on zero frequency:
```{r}
sp2$spec[1]
```

# Autocorrelation
  
>The autocorrelation consists in a cross-correlation of the signal against itself after a certain time lag (see Sect. 17.1). In other words the successive correlations are computed between s[n] and s[n + m], where m is the time lag, usually set to one audio sample. It is expected that correlation returns a maximal value when m = Tf where Tf is the period of the fundamental frequency. (ch.13.1.2, p.405)  
  
```{r}
ar1 <- spectrum(s, method = "ar", log = "no", plot = T, xlim = c(0, 0.1))
```
See ar1 parameters:
```{r}
str(ar1)
```
More comprehancive variant
```{r}
x.ac <- spectrum(s, method = "ar", log = "no", plot = FALSE)
acx <- x.ac$freq * f  # or multipy by f
acy <- 2*x.ac$spec
plot(acy ~ acx, xlab="frequency", ylab="spectral density", type="l", xlim = c(0, 2000)) #, ylim = c(0, 20000))
```
Frequencies to observe: c(0, 440, 880, 1320, 1760, 4400)  

Which frequency hax maximum:
```{r}
x.ac$freq[which.max(x.ac$spec)]*f
```


# Question

1) Is it need normalization for raw data?
2) Is it need detrending raw data for FFT?

