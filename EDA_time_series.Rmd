---
title: "Andrij Tymofeiu"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(zoo)
```

Тут будуть аналізуватися різні фічі для наших даних

# Code for feature extraction

1. Test rollapply() from zoo package
2. Calculate ...
  
# Get data

```{r, cache=TRUE}
data4features <- readRDS("data/preprocessing/pre_features_activity4.rds")
```
Choose user 1 data:
```{r, cache=TRUE}
(user1 <- filter(data4features, user_id == 1))
```

# Set sliding window parameters
   
The raw data is divided into identification intervals of 100 samples width with 50% overlap:  
Sampling freaquency: $f_s = 52 Hz$;  
Number of samples (sliding window length) $N = 100$;  
Length of data frame: $L = N \over f_s$ (2 sec max!)
```{r}
sample_Hz <- 52
sample_N <- 100 
overlap <- 0.5
length_DF <- round(sample_N / sample_Hz)
```

# 1. Test rollapply from zoo package

So, for **rollapply** function, the raw data been divided into identification intervals of 4 samples width with 50% overlap will look like:  
step 1: (4 + 5 + 7 + 4) / 4 = 5  
step 2: (7 + 4 + 9 + 8) / 4 = 7  
step 3: (9 + 8 + 4 + 3) / 4 = 6
```{r}
TS <- zoo(c(4, 5, 7, 4, 9, 8, 4, 3))
(ra <- rollapply(TS, width = 4, by = 2, FUN = mean))
```
Convert to integer:
```{r}
as.numeric(ra)
```

# 2 Magnitude calculation

Try to use geometric.mean from rollaply function 
[like here](https://stackoverflow.com/questions/31093987/how-to-calculate-rolling-geometric-mean-since-inception-in-r)  
  
Set test environment
```{r}
# Set test data
mag <- list(ax = (c(4, 5, 7, 4, 9, 8, 4, 3)),
           ay = (c(3, 4, 6, 3, 8, 7, 3, 2)),
           az = (c(5, 6, 8, 5, 10, 9, 5, 4)))

window_width <- 4

# Store result
test_res_mag <- list()

test_res_mag$slide1 <- sum(sqrt(mag$ax[1]^2 + mag$ay[1]^2 + mag$az[1]^2) +
    sqrt(mag$ax[2]^2 + mag$ay[2]^2 + mag$az[2]^2) +
    sqrt(mag$ax[3]^2 + mag$ay[3]^2 + mag$az[3]^2) +
    sqrt(mag$ax[4]^2 + mag$ay[4]^2 + mag$az[4]^2)) / window_width

test_res_mag$slide2 <- sum(sqrt(mag$ax[5]^2 + mag$ay[5]^2 + mag$az[5]^2) +
    sqrt(mag$ax[6]^2 + mag$ay[6]^2 + mag$az[6]^2) +
    sqrt(mag$ax[3]^2 + mag$ay[3]^2 + mag$az[3]^2) +
    sqrt(mag$ax[4]^2 + mag$ay[4]^2 + mag$az[4]^2)) / window_width

test_res_mag$slide3 <- sum(sqrt(mag$ax[5]^2 + mag$ay[5]^2 + mag$az[5]^2) +
    sqrt(mag$ax[6]^2 + mag$ay[6]^2 + mag$az[6]^2) +
    sqrt(mag$ax[7]^2 + mag$ay[7]^2 + mag$az[7]^2) +
    sqrt(mag$ax[8]^2 + mag$ay[8]^2 + mag$az[8]^2)) / window_width
```
Expected result:
```{r}
test_res_mag
```
Repeat the same with rollapply:
```{r}
# Form vector of magnitudes for raw data
scalar2mag <- pmap_dbl(mag, function(ax, ay, az) sqrt(ax^2 + ay^2 + az^2))
# Get result
rollapply(zoo(scalar2mag), width = 4, by = 2, FUN = mean)
```

# 2. How to calculate FFT for sliding windows

## 2.1 FFT for single user

Build spectrogramma on raw data replacing trends and constant value
```{r}
user1x.spec <- spectrum(user1$ax, log = "no", span = 10, plot = FALSE, detrend = T, demean = F)
spu1_x <- user1x.spec$freq * sample_Hz
spu1_y <- 2*user1x.spec$spec
plot(spu1_y ~ spu1_x, xlab = "frequency", ylab = "spectral density", type = "l", xlim = c(0, 10))
```
Let's make detrending signal by using diff() as suggest [here](https://stackoverflow.com/questions/14010605/fast-fourier-transform-in-r?rq=1)
```{r}
user1x.spec <- spectrum(diff(user1$ax), log = "no", span = 50, plot = FALSE, detrend = T, demean = T)
spu1_x <- user1x.spec$freq * sample_Hz
spu1_y <- 2*user1x.spec$spec
plot(spu1_y ~ spu1_x, xlab = "frequency", ylab = "spectral density", type = "l", xlim = c(0, 12))
```
Make spectrogram by hand replacing constant value:
```{r}
manual_spec <- function(x) {
  user1mx.spec <- Mod(fft(x))
  user1mx.spec[1] <- median(user1mx.spec)
  user1mx.spec.left <- 2*user1mx.spec[1:sample_Hz/2]
  plot(user1mx.spec, type="h", col="blue", xlab="Frequency (Hz)", ylab="Amplitude (no unit)", xlim = c(0, 2000))}

manual_spec(user1$ax)
```
The same but with diff():
```{r}
user1m2x.spec <- Mod(fft(diff(user1$ax)))
user1m2x.spec.left <- 2*user1m2x.spec[1:sample_Hz/2]
plot(user1m2x.spec, type="h", col="blue", xlab="Frequency (Hz)", ylab="Amplitude (no unit)", xlim = c(0, 2000))
```

Compare the total energy of time and frequence domain:
Time energy:
```{r}
sum(user1$ax^2)
```
Frequency energy by spectrum() 
```{r}
1/length(user1x.spec) * sum(user1x.spec$spec^2)
```
Frequency energy by manual:
```{r}
sum(Mod(fft(user1$ax))^2)
```

# 3. Peak detection

**How to make peak detection?**  
Do some investigation
```{r}
df_peak <- user1[1:100,]
ggplot(df_peak, aes(x = id, y = ax)) +
  geom_line(color = "red")
```
I've found this post here  
[Data Smoothing and Peak Detection](https://rpubs.com/mengxu/peak_detection)
```{r}
x <- df_peak$id
y <- df_peak$ax

argmax <- function(x, y, w=1, ...) {
  #require(zoo)
  n <- length(y)
  y.smooth <- loess(y ~ x, ...)$fitted
  y.max <- rollapply(zoo(y.smooth), 2*w+1, max, align="center")
  delta <- y.max - y.smooth[-c(1:w, n+1-1:w)]
  i.max <- which(delta <= 0) + w
  list(x=x[i.max], i=i.max, y.hat=y.smooth)
}

test.find.peak <- function(w, span) {
  peaks <- argmax(x, y, w=w, span=span)

  plot(x, y, cex=0.75, col="Gray", main=paste("w = ", w, ", span = ", span, sep=""))
  lines(x, peaks$y.hat,  lwd=2) #$
  y.min <- min(y)
  sapply(peaks$i, function(i) lines(c(x[i],x[i]), c(y.min, peaks$y.hat[i]), col="Red", lty=2))
  points(x[peaks$i], peaks$y.hat[peaks$i], col="Red", pch=19, cex=1.25)
}
```
See plot:
```{r}
test.find.peak(4, 0.05)
```

```{r}
test.find.peak(3, 0.1)
```
## 3.1 Choose parameters 'w' and 'span'

w = 3; span = 0.1
```{r}
peaks <- argmax(x, y, w = 3, span = 0.1)
peaks
```
## 3.2 Calculate average number of peaks per window

```{r}
length(peaks$x) / sample_N
```
## 3.3 Average distance between peaks

Distance between peaks refers to the average time interval between two successive peaks in a window
  
1) Get time values of peaks
```{r}
peaks$i
```
2) Calculate distance between each value:
```{r}
diff(peaks$i)
```
3) Calculate the mean of diff:
```{r}
mean(diff(peaks$i))
```
4) Additionaly calculate SD of peaks diffs:
```{r}
sd(diff(peaks$i))
```

## Absolute difference from mean (MAD - mean absolute deviation)

Test stats:mad() function
```{r}
x.even <- c(1,2,3,5,7,8)
x.odd <- c(1,2,3,5,7,8,9)

# Test median
test_median <- function(x, ...) {
  c(manual = median(abs(x - median(x))),
    mad = mad(x, center = median(x), constant = 1, ...))
}

# Test mean
test_mean <- function(x, ...) {
  c(manual = median(abs(x - mean(x))),
    mad = mad(x, center = mean(x), constant = 1, ...))
  }
```

### Test median

Odd variant:
```{r}
test_median(x.odd)
```
Even variant:
```{r}
test_median(x.even)
```
### Test mean

Odd variant:
```{r}
test_mean(x.odd)
```
Set low=T 
```{r}
test_mean(x.odd, high = T)
```
Even variant:
```{r}
test_mean(x.even)
```
Set low=T
```{r}
test_mean(x.even, low = T)
```


```{r}
median(abs(x.even - median(x.even)))
```
The same for the mean:
```{r}
mad(x.even, center = mean(x.even), constant = 1, low = F, high = F)
```

```{r}
median(abs(x.even - mean(x.even)))
```

# Test rollapply for absolute difference from mean

So, for **rollapply** function, the raw data been divided into identification intervals of 4 samples width with 50% overlap will look like:  

```{r}
TS <- zoo(c(4, 5, 7, 4, 9, 8, 4, 3))
x1 <- c(4, 5, 7, 4) # Vector for step 1
x2 <- c(7, 4, 9, 8) # Vector for step 2
x3 <- c(9, 8, 4, 3) # Vector for step 3
```
Expected answer:
## step1: x = c(4, 5, 7, 4)

```{r}
test_mean(x1)
```
## step2: x = c(7, 4, 9, 8)

```{r}
test_mean(x2)
```

## Let's dive into step 2:

### step 2.1: median(x)

```{r}
median(x2)
```
### step 2.2: x - median(x)

```{r}
x2 - median(x2)
```
### step 2.3: abs(x - median(x))

```{r}
abs(x2 - median(x2))
```
### step 2.4: median(abs(x - median(x)))

```{r}
median(abs(x2 - median(x2)))
```
## step3: x = c(9, 8, 4, 3)
```{r}
test_mean(x3)
```
Test rollapply: mad(x, center = mean(x), constant = 1)
```{r}
rollapply(TS, width = 4, by = 2, FUN = function(x)  mad(x, center = mean(x), constant = 1))
```
Set manual function for rollapply:
```{r}
rollapply(TS, width = 4, by = 2, FUN = function(x) mean(abs(x - mean(x))))
```

