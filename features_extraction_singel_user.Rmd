---
title: "Features Extraction"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)

library(tidyverse)
library(zoo)
```

# Set sliding window parameters
   
The raw data is divided into identification intervals of 100 samples width with 50% overlap:  
Sampling freaquency: $f_s = 52 Hz$;  
Number of samples (sliding window length) $N = 100$;  
Length of data frame: $L = N \over f_s$ (2 sec max!)
```{r}
sample_Hz <- 52
sample_N <- 100 
overlap <- 0.5
length_DF <- round(sample_N / sample_Hz)
```
  
## 2. Calculate features for particular user  

Get data:
```{r, cache=TRUE}
(data4features <- readRDS("data/preprocessing/pre_features_activity4.rds"))
```
1) Filter data for particular user  
```{r}
(user1 <- filter(data4features, user_id == 1))
```
2) Add columns of class 'zoo' for function rollapply() 
```{r}
# user1 %>% 
#   mutate(ax_zoo = zoo(ax),
#          ay_zoo = zoo(ay),
#          az_zoo = zoo(az)) -> user1
```
3) Add columns with FFT raw data transformation
```{r}
# user1 %>% 
#   mutate(ax_fft = Mod(fft(ax)),
#          ay_fft = Mod(fft(ay)),
#          az_fft = Mod(fft(az))) -> user1
```
3) Add columns raw_mag_xyz and fft_mag_xyz with magnitude of raw anf FFT data respectively
```{r}
# user1 <- user1 %>%
#   mutate(raw_mag = pmap_dbl(list(.$ax, .$ay, .$az), function(ax, ay, az) sqrt(ax^2 + ay^2 + az^2)) %>% round(),
#          fft_mag = pmap_dbl(list(.$ax_fft, .$ay_fft, .$az_fft),
#                             function(ax_fft, ay_fft, az_fft) sqrt(ax_fft^2 + ay_fft^2 + az_fft^2)) %>% round())
# user1
```

Make template for final tibble:
```{r}
features.extract <- list()
```
### 2.1 Mean  

Set function for mean calculation
```{r}
features.mean <- function(df) {
  rollapply(df, width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric() %>% round()}
```

### 1) raw_mean_ax
```{r}
features.extract$raw_mean_ax <- features.mean(zoo(user1$ax))
summary(features.extract$raw_mean_ax)
```

### Simplify version:

```{r}
zoo(user1$ax) %>% 
  rollapply(width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric %>% round %>% summary
```


### 2) raw_mean_ay
```{r}
features.extract$raw_mean_ay <- features.mean(zoo(user1$ay))
summary(features.extract$raw_mean_ay)
```
### 3) raw_mean_az
```{r}
features.extract$raw_mean_az <- features.mean(zoo(user1$az))
summary(features.extract$raw_mean_az)
```
For calculating mean for frequency domain we get rid constant value by using diff()
**IMPORTANT!!!** diff() is decrease length of input vector!
### 4) fft_mean_ax
```{r}
features.extract$fft_mean_ax <- features.mean(zoo(Mod(fft(diff(user1$ax)))))
summary(features.extract$fft_mean_ax)
```
### Simplify version:

```{r}
user1$ax %>% diff %>% fft %>% Mod %>% zoo %>% 
  rollapply(width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric %>% round %>% summary
```

### 5) fft_mean_ay:  
```{r}
features.extract$fft_mean_ay <- features.mean(zoo(Mod(fft(diff(user1$ay)))))
summary(features.extract$fft_mean_ay)
```
### 6) fft_mean_az:  
```{r}
features.extract$fft_mean_az <- features.mean(zoo(Mod(fft(diff(user1$az)))))
summary(features.extract$fft_mean_az)
```

## Median

```{r}
features.median <- function(df) {
  rollapply(df, width = sample_N, by = sample_N * overlap, FUN = median) %>% as.numeric() %>% round()}
```

### 7) raw_median_ax
```{r}
features.extract$raw_median_ax <- features.median(zoo(user1$ax))
summary(features.extract$raw_median_ax)
```
### 8) raw_median_ay
```{r}
features.extract$raw_median_ay <- features.median(zoo(user1$ay))
summary(features.extract$raw_median_ay)
```
### 9) raw_median_az
```{r}
features.extract$raw_median_az <- features.median(zoo(user1$az))
summary(features.extract$raw_median_az)
```
### 10) fft_median_ax
```{r}
features.extract$fft_median_ax <- features.median(zoo(Mod(fft(diff(user1$ax)))))
summary(features.extract$fft_median_ax)
```
### 11) fft_median_ay
```{r}
features.extract$fft_median_ay <- features.median(zoo(Mod(fft(diff(user1$ay)))))
summary(features.extract$fft_median_ay)
```
### 12) fft_median_az
```{r}
features.extract$fft_median_az <- features.median(zoo(Mod(fft(diff(user1$az)))))
summary(features.extract$fft_median_az)
```

## Magnitude

### 13) raw_mag

Prepare data to calculation
```{r}
raw_mag_fun <- function(df) {
  
  # Calculate magnitude array
  raw_mag <- pmap_dbl(list(df$ax, df$ay, df$az), function(ax, ay, az) sqrt(ax^2 + ay^2 + az^2)) %>% zoo()
  
  # Calculate magnitud for each sliding window
  rollapply(raw_mag, width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric() %>% round()
}
test <- raw_mag_fun(user1)
```
Calculate magnitude by sliding window
```{r}
features.extract$raw_mag <- raw_mag_fun(user1)
summary(features.extract$raw_mag)
```
### Simplify:
```{r}
pmap_dbl(list(user1$ax, user1$ay, user1$az), function(ax, ay, az) sqrt(ax^2 + ay^2 + az^2)) %>%  
  rollapply(width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric %>% round %>% summary
```

### 14) fft_mag  

#### 14.1 Prepare data to calculation

Make function that create magnitude from FFT data
```{r}
fft_mag_fun <- function(df) {
  
  # Make list with differential raw data
  mod.fft.xyz <- list(m.fft.x = Mod(fft(diff(df$ax))),
                      m.fft.y = Mod(fft(diff(df$ay))),
                      m.fft.z = Mod(fft(diff(df$az))))
  
  # Calculate magnitude
  mod.fft.xyz$mag <- pmap_dbl(mod.fft.xyz, function(m.fft.x, m.fft.y, m.fft.z) sqrt(m.fft.x^2 + m.fft.y^2 + m.fft.z^2)) %>% zoo()
  
  # Calculate magnitud for each sliding window
  rollapply(mod.fft.xyz$mag, width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric() %>% round()
}

test <- fft_mag_fun(user1)
```

#### 14.2 Calculate magnitude by sliding window

```{r}
features.extract$fft_mag <- fft_mag_fun(user1)
summary(features.extract$fft_mag)
```

```{r}
summary(fft_mag_fun(user1))
```

### Simplify:

[look here](https://stackoverflow.com/questions/46392282/map-function-to-second-level-of-nested-list-using-purrr)

1) Make FFT from raw data 
```{r}
user0 <- user1[1:10,]
list(user0$ax, user0$ay, user0$az) %>% map(~ .x %>% diff %>% fft %>% Mod %>% round)
```
2) Next step
```{r}
list(user1$ax, user1$ay, user1$az) %>% 
  map(~ .x %>% diff %>% fft %>% Mod) %>% # make fft from raw data
  pmap_dbl(function(ax, ay, az) sqrt(ax^2 + ay^2 + az^2)) %>%  #
    rollapply(width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric %>% round %>% summary
```

## Cross-correlation 

The cross correlation of z axis with x axis and y axis are mathematically defined as follows:  
$Corr _xy = x_ mean \over y_ mean$;  
$Corr _zy = z_ mean \over y_ mean$,  
  
Let's make some investigation
```{r}
test_corr <- tibble(corr_xy = features.extract$raw_mean_ax / features.extract$raw_mean_ay,
                    corr_zy = features.extract$raw_mean_az / features.extract$raw_mean_ay)
test_corr
```
Build some plots:
```{r}
test_corr %>% 
  ggplot(aes(x = seq(1:nrow(test_corr)), y = corr_xy)) +
    geom_line(color = "green") +
    geom_line(aes(x = seq(1:nrow(test_corr)), y = corr_zy), color = "red")
```
### 15(19) corr_xy
```{r}
features.extract$corr_xy <- features.extract$raw_mean_ax / features.extract$raw_mean_ay
summary(features.extract$corr_xy)
```
### 16(20) corr_zy
```{r}
features.extract$corr_zy <- features.extract$raw_mean_az / features.extract$raw_mean_ay
summary(features.extract$corr_zy)
```
### 17(-) corr_xy_fft
```{r}
features.extract$corr_xy_fft <- features.extract$fft_mean_ax / features.extract$fft_mean_ay
summary(features.extract$corr_xy_fft)
```
### 18(-) corr_zy_fft
```{r}
features.extract$corr_zy_fft <- features.extract$fft_mean_az / features.extract$fft_mean_ay
summary(features.extract$corr_zy_fft)
```

## Peak Count  
  
Peak count for each axis refers to the number of local maxima for the axial data in the identification window. The average of the peak count over the three axes for the time domain data is selected as a feature  
  
### Auxiliary functions for peak detections

Function find peaks by given parameters
```{r}
argmax <- function(x, y, w = 1, ...) {
  #require(zoo)
  n <- length(y)
  y.smooth <- loess(y ~ x, ...)$fitted
  y.max <- rollapply(zoo(y.smooth), 2*w+1, max, align="center")
  delta <- y.max - y.smooth[-c(1:w, n+1-1:w)]
  i.max <- which(delta <= 0) + w
  list(x = x[i.max], i = i.max, y.hat = y.smooth)
}
```
Parameters for peak.detection function:
```{r}
peak.detection.window <- 3 # w
peak.detection.span <- 0.1 # span
```
Function that calculate average number of peaks per window  
```{r}
avg.peaks <- function(user.ai) {
  rollapply(zoo(user.ai), width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(length(peaks$x) / sample_N)}) %>% as.numeric()} 
```
Test avg.peaks function:
```{r}
avg.peaks(user1$ax[1:200])
```

### 19(21) mean_peak_ax  

```{r}
features.extract$mean_peak_ax <- avg.peaks(user1$ax)
summary(features.extract$mean_peak_ax)
```

### Simplify for single value:
```{r}
user1$ax %>% 
  rollapply(width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(length(peaks$x) / sample_N)} %>% as.numeric) %>% summary

```

### 20(22) mean_peak_ay  

```{r}
features.extract$mean_peak_ay <- avg.peaks(user1$ay)
summary(features.extract$mean_peak_ay)
```

### 21(22) mean_peak_az  

```{r}
features.extract$mean_peak_az <- avg.peaks(user1$az)
summary(features.extract$mean_peak_az)
```

### Simplify for many values:

#### First test:

1) Set empty list:
```{r}
peak <- list()
```
2) Create 3 new columns and assign theirs to peak list
```{r}
map(list(user1$ax[1:200], user1$ay[1:200], user1$az[1:200]), function(x) {
  rollapply(x, width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(length(peaks$x) / sample_N)}) %>% as.numeric}) %>% set_names(c('ax1', 'ay1', 'az1')) %>% append(peak) -> peak
peak
```
3) Create next 3 new columns and assign theirs to peak list
```{r}
map(list(user1$ax[1:200], user1$ay[1:200], user1$az[1:200]), function(x) {
  rollapply(x, width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(length(peaks$x) / sample_N)}) %>% as.numeric}) %>% set_names(c('ax2', 'ay2', 'az2')) %>% append(peak) -> peak
peak
```
It works!!!

#### Check real data:

```{r}
peak4 <- list() 
map(list(user1$ax, user1$ay, user1$az), function(x) {
  rollapply(x, width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(length(peaks$x) / sample_N)}) %>% as.numeric}) %>% set_names(c('max2', 'may2', 'maz2')) %>% append(peak4) -> peak4
```
Check summary:
```{r}
map(peak4, summary)
```


## Distance between Peaks  

Distance between peaks refers to the average time interval between two successive peaks in a window

### Auxiliary functions

Function that calculate average distance between picks through windows
```{r}
avg.dist.peaks <- function(user.ai) {
  rollapply(zoo(user.ai), width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(mean(diff(peaks$i)))}) %>% as.numeric} 
```
Test avg.dist.peaks function:
```{r}
avg.dist.peaks(user1$ax[1:200])
```

### 22(24) peak_avg_dist_ax

```{r}
features.extract$peak_avg_dist_ax <- avg.dist.peaks(user1$ax)
summary(features.extract$peak_avg_dist_ax)
```

### 23(25) peak_avg_dist_ay

```{r}
features.extract$peak_avg_dist_ay <- avg.dist.peaks(user1$ay)
summary(features.extract$peak_avg_dist_ay)
```

### 24(26) peak_avg_dist_az

```{r}
features.extract$peak_avg_dist_az <- avg.dist.peaks(user1$az)
summary(features.extract$peak_avg_dist_az)
```

## Additionaly calculate SD of peaks diffs

Function that calculate standard deviation of average distance between picks through windows
```{r}
sd.dist.peaks <- function(user.ai) {
  rollapply(zoo(user.ai), width = sample_N, by = sample_N * overlap, 
            FUN = function(z) {
              id <- 1:length(z)            
              peaks <- argmax(x = id, y = z, w = peak.detection.window, span = peak.detection.span)
              return(sd(diff(peaks$i)) / sample_N)}) %>% as.numeric} 
```
Test avg.dist.peaks function:
```{r}
sd.dist.peaks(user1$ax[1:200])
```
### 25(-) peak_sd_dist_ax

```{r}
features.extract$peak_sd_dist_ax <- sd.dist.peaks(user1$ax)
summary(features.extract$peak_sd_dist_ax)
```

### 26(-) peak_sd_dist_ay

```{r}
features.extract$peak_sd_dist_ay <- sd.dist.peaks(user1$ay)
summary(features.extract$peak_sd_dist_ay)
```

### 27(-) peak_sd_dist_az

```{r}
features.extract$peak_sd_dist_az <- sd.dist.peaks(user1$az)
summary(features.extract$peak_sd_dist_az)
```

## Spectral Centroid  
  
Spectral centroid is a measure used to characterise a spectrum. In this case, spectrum refers to the identification window of acceleration values. It indicates where the center of mass of the spectrum is. The spectral centroid of each window for the three axes using the FFT values as weights is given by:  
$$Centroid = \sum_ { k = 1 }^l { x_tk f_tk } \over { l }$$  
where:  
$x_tk$ - Instantaneous acceleration   
$f_tk$ - Instantaneous value of FFT  
l      - length of window  

### Auxiliary functions

Make function that create magnitude from FFT data
```{r}
spectral.centroid <- function(user.ai) {
  # Calculate FFT. After applaying diff() input array has n-1 length!
  mod.fft <- Mod(fft(diff(user.ai))) %>% round
  
  # Align the vector along the length by adding the median as the last element
  mod.fft[length(mod.fft) + 1] <- mod.fft[median(mod.fft)]
  
  # Calculate spectral centroid for current window
  spec.centr <- list(centroid = zoo(user.ai * mod.fft))
  
  # Calculate spectral centroid through all windows
  rollapply(spec.centr$centroid, width = sample_N, by = sample_N * overlap, FUN = mean) %>% as.numeric %>% round
}
```
Test spectral.centroid function
```{r}
spectral.centroid(user1$ax[1:201])
```

### 28(27) spectral_centr_ax

```{r}
features.extract$spectral_centr_ax <- spectral.centroid(user1$ax)
summary(features.extract$spectral_centr_ax)
```

### 29(28) spectral_centr_ay;  

```{r}
features.extract$spectral_centr_ay <- spectral.centroid(user1$ay)
summary(features.extract$spectral_centr_ay)
```

### 30(29) spectral_centr_az

```{r}
features.extract$spectral_centr_az <- spectral.centroid(user1$az)
summary(features.extract$spectral_centr_az)
```

## Average Difference from Mean  

The absolute difference from mean of the window for each axis (time domain) is calculated as follows:  
$Diff_x = Avg( \abs{ x_t - x_mean } )$  
where:  
$Diff_x$ - Difference from mean   
$x_t$    - Instantaneous acceleration  

Make function that calculate the absolute difference from mean of the window
```{r}
abs.diff.mean <- function(user.ai) {
  
  # Calculate absolute difference from mean of the window
  window.abs.diff <- rollapply(user.ai, width = sample_N, by = sample_N * overlap,
                               FUN = function(x) mean(abs(x - mean(x)))) %>% as.numeric %>% round
}
```
Test spectral.centroid function
```{r}
aa <- abs.diff.mean(user1$ax[1:200])
aa
```   
   
### 31(30) avg_diff_mean_ax

```{r}
features.extract$avg_diff_mean_ax <- abs.diff.mean(user1$ax)
summary(features.extract$avg_diff_mean_ax)
```

### 32(31) avg_diff_mean_ay

```{r}
features.extract$avg_diff_mean_ay <- abs.diff.mean(user1$ay)
summary(features.extract$avg_diff_mean_ay)
```

### 33(32) avg_diff_mean_az

```{r}
features.extract$avg_diff_mean_az <- abs.diff.mean(user1$az)
summary(features.extract$avg_diff_mean_az)
```

So now we have complete list of features for single user!!!
